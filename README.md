# <p align="center">Лабораторная работа №1</p>

Вариант 25. Очередь с приоритетом. Вставка элемента в очередь. Взятие элемента из очереди.

## <p align="center">Цели лабораторной работы:</p>
1. Разработать библиотеку для работы с очередью с приоритетом на выбранном императивном языке программирования (например, C++, Java, Python).
2. Создать тестовую программу для демонстрации функциональности разработанной библиотеки.
3. Разработать систему тестов для проверки работоспособности и корректности библиотеки, учитывая требования полноты, адекватности и непротиворечивости.
4. Обеспечить обработку некорректных данных, предусмотрев корректное завершение программы при возникновении ошибок.
5. Составить отчет по выполнению лабораторной работы.
   
## <p align="center">Задачи лабораторной работы:</p>
1. Изучить спецификацию задачи по работе с очередью с приоритетом.
2. Выбрать язык программирования для реализации библиотеки (например, C++, Java, Python) в соответствии с индивидуальным заданием.
3. Разработать и реализовать библиотеку для работы с очередью с приоритетом, включая операции вставки и извлечения элементов.
4. Написать тестовую программу, которая демонстрирует основные сценарии использования библиотеки.
5. Разработать систему тестов, включающую тест-кейсы для проверки различных аспектов работы библиотеки, включая корректность, производительность и обработку ошибок.
6. Провести тестирование разработанной библиотеки, убедившись в ее правильной работе на различных входных данных.
7. Составить подробный отчет, включая описание решения задачи, архитектуры библиотеки, результаты тестирования и выводы.

## <p align="center">Список используемых понятий и алгоритмов:</p>
1. **Приоритетная очередь:**
   Приоритетная очередь (англ. priority queue) — это абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом.

2. **Двоичная куча (Binary Heap):**
   Двоичная куча представляет собой вид двоичного дерева, которое соответствует следующим трем условиям:
   - **Сортировка значений:** Значение в каждой вершине не меньше, чем значения её потомков. В случае мин-кучи, значение в каждой вершине не больше значений её потомков, в макс-куче — не меньше.
   - **Балансировка глубины:** Разница в глубине листьев (расстояние от корня до листа) не превышает 1 слой. Это обеспечивает сбалансированность дерева и эффективное использование памяти.
   - **Заполнение слоев слева направо:** Последний слой дерева заполняется слева направо, без пропусков. Это обеспечивает эффективное хранение данных в виде массива.

3. **Операции вставки и извлечения:**
   - **Вставка (insert):** Операция добавления нового элемента в структуру данных. В контексте приоритетной очереди, элемент вставляется с учетом его приоритета.
   - **Извлечение (extract):** Операция удаления и возврата элемента с наивысшим приоритетом из структуры данных.

4. **Методы поддержки структуры данных:**
   - **Метод `up(i)`:** Поднимает элемент вверх по дереву, обеспечивая корректность структуры данных после вставки.
   - **Метод `down(i)`:** Спускает элемент вниз по дереву, обеспечивая корректность структуры данных после извлечения.

5. **Исключение `std::out_of_range`:**
   Исключение, используемое в C++, чтобы сигнализировать о выходе индекса за пределы допустимого диапазона. В данном контексте, используется для обработки попыток извлечения из пустой приоритетной очереди.

6. **Тестирование с использованием Google Test:**
   Google Test — это фреймворк для написания тестов в языке программирования C++. Тестирование с его использованием обеспечивает автоматизацию проверок и обеспечивает надежность кода.

## <p align="center">Описание используемых алгоритмов:</p>
1. **Бинарная куча (Heap):**
В своей библиотеке я реализовывал бинарную (двоичную) кучу через `std::vector`. Где n-ому элементу, соответствовали элементы 2n+1 и 2n+2.

<p align="center">
  <img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/binaryheap.png" alt="Двоичная куча через вектор">
</p>

2. **Метод вставки (insert):**
Отвечает за вставку нового элемента в приоритетную очередь. Этот метод добавляет элемент в конец вектора и затем вызывает метод up, который поднимает элемент вверх по дереву для обеспечения соблюдения условий бинарной кучи.
    - **Вспомогательный метод up:**
    Отвечает за подъем элемента вверх по дереву для восстановления условий бинарной кучи после вставки. Этот метод выполняет цикл, сравнивая значение текущего элемента с его родителем и меняя их местами при необходимости до тех пор, пока элемент не достигнет правильной позиции.

```cpp
void priorityQueue::insert(int value) {
	a.push_back(value);
	up(a.size() - 1);
}

void priorityQueue::up(int i) {
	while (a[i] > a[(i - 1) / 2] && i != 0) {
		swap(a[(i - 1) / 2], a[i]);
		i = (i - 1) / 2;
	}
}
```

3. **Метод извлечения (extract):**
Отвечает за извлечение элемента с наивысшим приоритетом из приоритетной очереди. Этот метод извлекает значение из корня, заменяет корень последним элементом вектора, а затем вызывает метод down, который опускает новый корень вниз по дереву для восстановления условий бинарной кучи. Также учитыется случай, когда происходит попытка извлечения из пустой очереди, для этого случая создано исключение `std::out_of_range` 
    - **Вспомогательный метод down:**
    Отвечает за опускание элемента вниз по дереву для восстановления условий бинарной кучи после извлечения. Этот метод выполняет цикл, сравнивая значение текущего элемента с его потомками и меняя его место с наибольшим из потомков, если это необходимо, до тех пор, пока элемент не достигнет правильной позиции.

```cpp
int priorityQueue::extract() {
	if (isEmpty()) {
		throw out_of_range("Priority queue is empty");
	}

	int value = a[0];
	a[0] = a[a.size() - 1];
	a.pop_back();
	down(0);
	return value;
}

void priorityQueue::down(int i) {
	while (2 * i + 1 < a.size()) {
		int maxChild = 2 * i + 1;
		if (maxChild + 1 < a.size() && a[maxChild] < a[maxChild + 1])
			maxChild++;
		if (a[i] >= a[maxChild])
			break;
		swap(a[maxChild],a[i]);
		i = maxChild;
	}
}
```
   
4. **Метод проверки пустой очереди (isEmpty):**
Проверяет, пуста ли приоритетная очередь. Возвращает true, если вектор a пуст, и false в противном случае.

```cpp
bool priorityQueue::isEmpty() const {
	return a.empty();
}
```

5. **Алгоритм работы очереди с приоритетом:**

    1. **Инициализация:**
       - Создание экземпляра класса `priorityQueue`.
       - Внутренний вектор `a` используется для хранения элементов в виде бинарной кучи.
    
    2. **Вставка элемента:**
       - Новый элемент добавляется в конец вектора.
       - Вызывается метод `up` для восстановления условий бинарной кучи.
    
    3. **Извлечение элемента:**
       - Проверка наличия элементов в куче.
       - Извлечение значения из корня (с наивысшим приоритетом).
       - Замена корня последним элементом вектора.
       - Вызов метода `down` для восстановления условий бинарной кучи.
    
    4. **Подъем элемента вверх:**
       - Пока текущий элемент больше родителя и не достигнут корень:
         - Меняем местами текущий элемент и его родителя.
         - Обновляем индекс текущего элемента.
    
    5. **Опускание элемента вниз:**
       - Пока есть хотя бы один потомок текущего элемента:
         - Выбираем максимального из потомков.
         - Если текущий элемент меньше выбранного потомка, меняем их местами.
         - Обновляем индекс текущего элемента.
    
    6. **Проверка наличия элементов:**
       - Проверка, пуста ли куча, основываясь на пустоте вектора `a`.

## <p align="center">Используемые источники:</p>
1. https://neerc.ifmo.ru/wiki/index.php?title=Приоритетные_очереди#.D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8 (определения понятий)
2. 
